# Архитектура
Архитектура проекта. Организация кода.

- namespace - пространство имён `namespace.md`
- use - пространство имён `use.md`
- строка 179, начни отсюда

# namespace и создание класса
Для создания PHP класса с несколькими свойствами и методами, а также для предотвращения конфликтов имен классов, стоит воспользоваться пространствами имен (`namespaces`). Пространства имен позволяют организовать классы в логические группы и избежать коллизии имен.

Вот пример простого PHP-класса `User`, который находится в пространстве имен `App\Models`.

```php
namespace App\Models;

class User {
  private $id;
  private $name;
  private $email;

  public function __construct($id, $name, $email) {
    $this->id = $id;
    $this->name = $name;
    $this->email = $email;
  }

  // Геттеры и сеттеры
  public function getId() {
    return $this->id;
  }

  public function setName($name) {
    $this->name = $name;
  }

  public function getEmail() {
    return $this->email;
  }

  // Метод для вывода информации о пользователе
  public function displayInfo() {
    echo "ID: {$this->getId()}<br>";
    echo "Имя: {$this->name}<br>";
    echo "Email: {$this->email}<br>";
  }
}
```

Теперь давайте рассмотрим, как организовать файлы и структуру проекта, чтобы избежать конфликтов между классами.

## Архитектура файлов

### Структура директорий
Предположим, у нас есть простое веб-приложение с такой структурой:

```
/app
  /Models
    User.php
  /Controllers
    MainController.php
/public
  index.php
/vendor
  composer.json
composer.lock
```

### Файл автозагрузки Composer
Для автоматического подключения классов и избежания необходимости вручную подключать каждый файл, используем Composer. В файле `composer.json` добавляем секцию `autoload`:

```json
{
  "require": {},
  "autoload": {
    "psr-4": {
      "App\\": "app/"
    }
  }
}
```

Эта конфигурация указывает Composer, что пространство имен `App` соответствует папке `/app`. Теперь все классы внутри этой папки будут автоматически загружаться.

### Подключение автозагрузчика
В корневом файле приложения (например, `index.php`) подключаем автозагрузчик Composer:

```php
// Подключаем автозагрузчик Composer
require_once __DIR__ . '/vendor/autoload.php';

use App\Models\User;
use App\Controllers\MainController;

$user = new User(1, 'Иван', 'ivan@example.com');
$user->displayInfo();

$controller = new MainController();
$controller->handleRequest();
```

### Как предотвратить конфликты имен
Использование пространства имен позволяет изолировать классы друг от друга. Например, если другой разработчик создаст свой класс `User` в своем пространстве имен, то эти два класса не будут конфликтовать.

Пример другого класса `User` в другом пространстве имен:

```php
namespace AnotherApp\Models;

class User {
  // Свойства и методы этого класса
}
```

Таким образом, вы можете обращаться к разным версиям класса `User`, используя их полные имена, включающие пространство имен:

```php
use App\Models\User as AppUser;
use AnotherApp\Models\User as AnotherUser;

$appUser = new AppUser(1, 'Иван', 'ivan@example.com');
$anotherUser = new AnotherUser('Алексей', 'alexey@example.com');
```

## Итог
Используя пространства имен и автозагрузчики, такие как Composer, вы сможете легко управлять своими классами, избегая конфликтов имен и обеспечивая четкую организацию кода вашего PHP-приложения.

# А что находится в файле autoload.php?
Файл `autoload.php`, который генерируется Composer'ом, отвечает за автоматическое подключение классов в вашем проекте. Когда вы устанавливаете зависимости через Composer, он создает этот файл в папке `/vendor`. Давайте разберем, что именно происходит в этом файле.

## Что делает autoload.php
Когда вы вызываете `require_once __DIR__ . '/vendor/autoload.php';` в начале вашего скрипта, Composer начинает загружать необходимые классы, основываясь на конфигурации, которую вы указали в `composer.json`. Вот основные задачи, которые выполняет `autoload.php`:

1. **Подключение классов PSR-4**: Стандарт PSR-4 определяет способ загрузки классов на основе их пространств имен. В примере выше мы настроили Composer так, чтобы он искал классы в пространстве имен `App` в папке `/app`. Таким образом, когда вы создаете новый класс, например, `App\Models\User`, Composer знает, где искать соответствующий файл.

2. **Загрузка зависимостей**: Если ваш проект использует сторонние библиотеки, установленные через Composer, `autoload.php` также будет загружать их классы. Это позволяет вам использовать функции и классы этих библиотек без необходимости вручную подключать их файлы.

3. **Кэширование путей**: Для повышения производительности Composer кэширует пути к классам, чтобы не приходилось каждый раз искать их на диске. Это особенно полезно в больших проектах с множеством классов.

## Пример содержимого autoload.php
Хотя содержимое файла `autoload.php` генерируется автоматически и обычно не требует изменений, вот упрощенный пример того, как он может выглядеть:

```php
// Автозагрузчик PSR-4
spl_autoload_register(function ($class) {
  $prefixes = [
    'App\\' => __DIR__ . '/../app',
    // Другие пространства имен могут быть добавлены сюда
  ];

  foreach ($prefixes as $prefix => $baseDir) {
    if (strpos($class, $prefix) === 0) {
      $file = $baseDir . str_replace('\\', '/', substr($class, strlen($prefix))) . '.php';
      if (is_file($file)) {
        require $file;
        break;
      }
    }
  }
});

// Загружает классы сторонних библиотек
include __DIR__ . '/composer/include_paths.php';

// Кэшированные пути к классам
$vendorDir = dirname(__DIR__);
$baseDir = dirname($vendorDir);
return array(
  'Psr\\Log\\' => $baseDir . '/psr/log/Psr/Log/',
  'Monolog\\' => $vendorDir . '/monolog/monolog/src/Monolog/',
  // Другие классы могут быть добавлены сюда
);
```

Этот код регистрирует функцию автозагрузки, которая ищет классы в соответствии с указанными пространствами имен и путями. Он также включает файл `include_paths.php`, который содержит информацию о загрузке сторонних библиотек.

## Заключение
Файл `autoload.php` играет ключевую роль в организации и управлении классами в вашем PHP-проекте. Использование Composer и пространства имен помогает избежать конфликтов имен и обеспечивает удобную работу с большим количеством классов и библиотек.

# Как организовать архитектуру в ручную без composer, по простому?
Организация автозагрузки классов вручную без использования Composer возможна, но потребует немного больше усилий. Однако это хороший способ понять, как работает автозагрузка в PHP, и научиться создавать собственные решения.

## Шаги для ручной реализации автозагрузки

1. **Создание структуры проекта**

Начнем с простой структуры проекта:

```
/src
    /Models
        User.php
    /Controllers
        MainController.php
/public
    index.php
autoload.php
```

2. **Написание класса `User`**
Создадим класс `User` в файле `src/Models/User.php`:

```php
namespace Models;

class User {
  private $id;
  private $name;
  private $email;
  
  public function __construct($id, $name, $email) {
      $this->id = $id;
      $this->name = $name;
      $this->email = $email;
  }

  // Геттеры и сеттеры
  public function getId() {
      return $this->id;
  }

  public function setName($name) {
      $this->name = $name;
  }

  public function getEmail() {
      return $this->email;
  }

  // Метод для вывода информации о пользователе
  public function displayInfo() {
      echo "ID: {$this->getId()}<br>";
      echo "Имя: {$this->name}<br>";
      echo "Email: {$this->email}<br>";
  }
}
```

3. **Автозагрузчик**
Теперь создадим файл `autoload.php`, который будет отвечать за автозагрузку классов:

```php
<?php

spl_autoload_register(function ($class) {
  $path = str_replace('\\', DIRECTORY_SEPARATOR, $class) . '.php';
  $fullPath = __DIR__ . '/src/' . $path;

  if (file_exists($fullPath)) {
      include $fullPath;
  }
});
```
Здесь используется функция `spl_autoload_register`, которая регистрирует пользовательскую функцию для автозагрузки классов. Эта функция преобразует имя класса в путь к файлу и пытается включить его.

4. **Основной скрипт**
Наконец, в файле `public/index.php` подключим автозагрузчик и воспользуемся нашим классом `User`:

```php
require_once '../autoload.php';

use Models\User;

$user = new User(1, 'Иван', 'ivan@example.com');
$user->displayInfo();
```

## Объяснение
1. **Пространство имен**: Мы использовали пространство имен `Models` для нашего класса `User`. Это помогает организовывать классы и избегать конфликтов имен.
2. **Функция автозагрузки**: Функция `spl_autoload_register` регистрирует нашу пользовательскую функцию для поиска и включения файлов классов. Она принимает полное имя класса (включая пространство имен), преобразует его в путь к файлу и проверяет существование файла перед его включением.
3. **Путь к файлам**: Путь к файлам строится относительно корня проекта. В нашем случае все классы находятся в папке `src`, поэтому мы добавляем эту часть пути к имени класса.

## Преимущества и недостатки
**Преимущества**:
- Полный контроль над процессом автозагрузки.
- Возможность настройки под конкретные нужды проекта.
**Недостатки**:
- Требуется писать и поддерживать собственный код автозагрузки.
- Отсутствие поддержки зависимостей и автоматического обновления версий библиотек.

Ручная реализация автозагрузки может быть полезна в небольших проектах или для обучения, но в реальных приложениях предпочтительнее использовать инструменты вроде Composer, которые предоставляют готовые решения и облегчают управление зависимостями.
