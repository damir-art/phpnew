# MySQL

Реляционные базы состоят из таблиц и связей между ними.  
Перед тем как создать таблицу, нужно выяснить какими свойствами обладает сущность, для которой мы создаём таблицу.  
Таблица это списко сущностей, какждая строка это отдельная сущность.  
У каждой таблицы, помимо свойств, также имеется первичный ключ - уникальный для каждой сущности, который не меняется, например `id_tableName`.  

Создадим таблицу работники `workers`:

| id_worker | name | cost | phone | email | dep | dep_phone |
| - | - | - | - | - | - | - |
| 1 | Ivan | 1000 | 111-111 | 1@1.ru | it | 8-111 |
| 2 | Petr | 1500 | 222-222 | 2@2.ru | marketing | 8-222 |
| 3 | Sidor | 1200 | 333-333 | 3@3.ru | it | 8-333 |

Важно понимать что столбец в таблице гораздо важнее строки.  
Столбцы, таблицы и связи это структурная информация.  
Изменения связанные со структурой (DDL) происходят крайне редко.  
Работа со строками это изменение данных (DML).

Изменения данных происходят постоянно: добавление, изменение, удаление строк.  
Есть еще побочный идентификатор уникью поля, в нашей таблице это могли быть поля с емаил и телефоном.

Если посмотреть на столбец `dep` то можно заметить что проигнорирована связь которая нужна для избавления дублей (нужно создать отдельную таблицу и назвать её департаменты).  
Также если у департаментов будут свои телефоны, то при переходе работника из одного департамента в другой придется помнить что нужно еще поменять и телефон.  
Разработчик должен знать как мнимум три нормальные формы.

## Связи между сущностями
Создадим таблицу `departaments`. У таблицы `workers` удаляем два последних столбца.

| id_dep | name | phone | email | address |
| - | - | - | - | - |
| 1 | it | 8-111 | it@mail.ru | 2 floor |
| 2 | marketing | 8-222 | marketing@mail.ru | 3 floor |

Привязываем сотрудников к департаментам. Пытаемся вычислить тип связи между таблицами. В одном департамента много сотрудников, сотрудник может принадлежать к одному отделу. Один ко многим. Принидлежность к какому-то отделу это свойство сотрудника, добавляес в таблицу `workers`, свойство `id_dep`.

| id_worker | name | cost | phone | email | id_dep |
| - | - | - | - | - | - |
| 1 | Ivan | 1000 | 111-111 | 1@1.ru | 1 |
| 2 | Petr | 1500 | 222-222 | 2@2.ru | 2 |
| 3 | Sidor | 1200 | 333-333 | 3@3.ru | 1 |

Рассмотрим пример когда у сотрудника несколько телефонов (рабочий, домашний, экстренный). Мы не можем их записать в столбец `phone` через запятую, чтобы не нарушить первую нормальную форму (данные должны быть атомарными).

Создаём таблицу `phones` (например у работника с ID = 1 два телефона), из таблицы `workers` удаляем столбец `phone`:

| id_phone | phone | id_worker |
| - | - | - |
| 1 | 111 | 1 |
| 2 | 222 | 1 |
| 3 | 333 | 2 |
| 3 | 444 | 3 |

## БД, СУБД
БД - это база данных, файлы.  
СУБД - это система управления базой данных, понимающий синтаксис SQL.

В XAMPP по адресу http://localhost/dashboard/ написано Apache + MariaDB + PHP + Perl.  
MariaDB ответвление от MySQL, которая не требует лицензии.  
Включаем на XAMPP, MySQL, переходим в http://localhost/phpmyadmin/

## phpMyAdmin
Создание базы данных:
- Базы данных
- php1
- utf8mb4_general_ci

Создание таблицы:
- departaments
- Количество столбцов не имеет значения, оставьте 4 по-умолчанию

Поля:
- Сравнение - это выбор кодировки, если не задана, то берется кодировка таблицы или базы
- Комментарии - поля идущие после него можно не заполнять
- Имя: id_dep, title, phone, email, address
- Тип: INT, VARCHAR, VARCHAR, VARCHAR, VARCHAR
- Длина/Значения: пусто, 256, 32, 64, 256
- По умолчанию: ничего не делать
- Сравнение: ничего не делать
- Атрибуты: Unsigned, , , , ,
- Null: может ли поле быть пустым? если да то ставим галочку
- Индекс: PRIMARY (вперед), , , , ,
- A_i: галочка, , , , ,
- Сохранить

Добавляем строку:
- Вставить
- IT, 111, it@dep.ru, ул.ИТ, д.404

Почему для VARCHAR задаём длину? Для него можно поставить INDEX, который позволяет ускорить поиск.

## Создание сложной таблицы
Создадим сайт агрегатор с несколькими таблицами. Есть таблица с товарами, есть таблицами с магазинами, есть таблица связывающая эти две таблицы через составной первичный ключ. Еще четвертая таблица с категориями товаров.

Когда таблиц много, начинать создавать нужно с простых.

### Таблица shops
- id_shop: INT, UNSIGNED, PRIMARY, A_i
- title: VARCHAR, 256
- site: VARCHAR, 128
- address: VARCHAR, 256, NULL (значение по-умолчанию), Null (ставим галочку, разрешаем быть NULL, если у некоторых магазинов нет физическго адреса)
- Сохранить

Вставляем данные:
- МВидео, mvideo.ru, Москва
- и еще 3 любых магазина

### Таблица cats
- id_cat: SMALLINT, UNSIGNED, PRIMARY, A_i
- title: VARCHAR, 256
- Сохранить

Вставляем данные:
- Phones
- Notebooks

### Таблица products
- id_product: INT, UNSIGNED, PRIMARY, A_i
- id_cat: SMALLINT, UNSIGNED
- title: VARCHAR, 256
- description: TEXT
- dt_add: TIMESTAMP, CURRENT_TIMESTAMP

Вставляем данные:
- 1, iPhone X, 123
- 1, iPhone XX, 1234
- 2, Note Asus NZ2, 12345

### Таблица shops_products
Таблица с составным первичным ключом.
- id_shop, id_product (составной ключ, имена такие же как и у соответствующих таблиц)
- INT, INT
- UNSIGNED, UNSIGNED
- PRIMARY, PRIMARY
- не ставим автоинкремент

Отсальные поля:
- cost (стоимость): INT, UNSIGNED 
- rest (остаток на складе): SMALLINT, UNSIGNED

Изменяем rest ставим по умолчанию (как опредделено - 0).

Добавляем товары:
- 1, 1
- 1, 2

Появится ошибка потому что cost не задан, добавляем его вручную потому что товары уже добавились но без цены.

Добавляем еще товар:
- 2, 3, 20000
- 3, 3, 75000

## INDEX, Уникальный
INDEX ставится тем полям по которым происходит поиск, например авторизация происходит по емаил и паролю. Ставим INDEX полю емаил. Таблица > Структура > Еще (в конце строки поля). Вместо INDEX еще можно поставить `Уникальный` (INDEX + не может повторяться). Ставим уникальный.

Поиск благодяря INDEX становится быстрее (бинарный поиск а не линейный), но операции добавления, удаления, редактирования становятся немного медленней.

## Создаём связи между таблицами
При изменении одной ячейки, изменения должны происходит автоматически и в других таблицах. Например удаляем товар в таблице `products`, в таблице shops_products данные остались, хотя должны удаляться тоже.

Делаем связь между таблицами на уровне базы.
- Переходим в базу данных
- жмем по `Дизайнер`
- сбоку жмем "Создать ссылку"
- сначала жмем по cats.id_cat затем products.id_cat
- нам скажут что нужно сделать индексной столбец products.id_cat (ALTER TABLE `products` ADD INDEX(`id_cat`);)

Снова ставим ссылку, нас спросят что делать при удалении или при обновлении:
- cascade - данные удалятся из всех связанных таблиц
- set null - установить null
- no action - ничег не делать
- restrict - запрет на удаление
Ставим restrict два раза.

Выбираем сбоку переключение линий ссылки.
- должна япоявится линия от cats в products (линия заканчивается полукружком, один к многим)

Делаем связь между shops.id_shop и shops_products.id_shop (cascade, cascade).
- выдаст ошибку потому что нарушена связь
- надо в shops_products поставить id существующего магазина

Делаем связь между product.id_product и shops_products.id_product (cascade, cascade).

Теперь при добавлении элементов в таблицу в phpMyAdmin там где есть связь, показывается что мы добавляем а не просто сами числа вводим.

Если удалить магазин из таблицы shops, то данные магазина с товарами которые в нем удалятся и из перекрестной таблицы shops_products.
