# post up
От варианта выбора хранилища и что вы собираетесь делать с этими данными, зависит какие функции писать для них. Например для логов, запись данных в конец текстового файла. Для чтения данных, лучше использовать формат JSON. Поиск и редактирование данных - MySQL.

Сделаем свой придуманный способ хранения информации (свой формат). 
- чтение и добавление одной заявки слишком ресурсоемко, поскольку надо брать всю базу и только потом туда добавлять
- мы не можем читать одну заявку надо считывать весь массив
- данные лежат в монолите, нет возможности читать часть данных, пока он не считывается и не декодируется целиком

Свой формат:
- каждая строка в файле описывает одну заявку
- каждая заявка сосотит из N частей

При этом JSON формат дружелюбен для редактирования, а рассматриваемый в этом уроке не дружелюбен для редактирования, но дружелюбен для добавления информации в конец файла, подходит ля имутабельных вещей (которые не меняются, не редактируются, например логи).

Так как у приложения file/post-json.md хорошая архитектура, нам достаточно изменить логику в файле model/apps.php. Для начала сотрем всё в файле db/apps.txt

Этих функци хватит для решения большинства задач связанных с хранением какой-либо информации в файле:
- file_get_contents()
- file_put_contents()
- file()

Но бывают ситуации когда файл слишком большой, например спарсенный список товаров или базу клиентов, внести на сайт. И получается что функция file() создаёт массив строк, и если она создаст 500 тыс строк, то создастся массив на 500 тыс элементов, а это уже риск для оперативной памяти.

Поэтому для таких файлов нужно использовать функции для низкоуровневой работы с файлами. Менее удобны для программиста, но больше удобны для железа. В этом случае файлы не считываются целиком, а работают с дескриптором (указателем).

## apps.php

    <?php
    // Добавляем одну заявку к списку, а не все скопом + одна заявка
    // Избавляемся от метода saveApps()

    // Превращаем файл со строками в многомерный массив
    function getApps() : array{
      $lines = file('db/apps.txt'); // превращает файл в массив строк
      // echo '<pre>';
      // print_r($lines);
      // echo '</pre>';
      $apps = []; // создаём пустой массив
      
      // можно воспользоваться функцией array map
      foreach($lines as $line) {
        $apps[] = appStrToArr($line); // передаем строку для обрабаотки, возвращенный массив вставляем в $apps
      }
      
      return $apps;
    }

    // Каждую строку в файле превращаем в элемент многомерного массива и ассоциативный массив
    // На каждой итерации цикла в getApps(), функция appStrToArr() принимает строку
    function appStrToArr(string $str) : array{
      $str = rtrim($str); // обрезает переносы в конце строки, например \n
      $parts = explode(';', $str); // разбивает строку в массив, по разделителю

      // ключи dt и остальные, это те ключи которые есть в контроллере admin.php
      return ['dt' => $parts[0], 'name' => $parts[1], 'phone' => $parts[2]]; // возвращаем ассоциативный массив
    }

    // Данный метод хорош только для записи данных, а не для получения, считывания или редактирования
    // ведение логов, журнала посещения сайта, заявки
    function addApp(string $name, string $phone) : bool{
      $dt = date("Y-d-m H:i:s");
      $app = "$dt;$name;$phone\n"; // Записываем в строку данные из формы, разделяемые точкой с запятой, в конце ставим перенос строки, чтобы каждая заявка хранилась в отдельной строке
      file_put_contents('db/apps.txt', $app, FILE_APPEND); // С помощью третьего параметра добавляем строку в конец
      return true;
    }
